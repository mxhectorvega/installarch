#!/usr/bin/env bash

# Script para transformar Arch Linux en un
# sistema inmutable con actualizaciones
# transaccionales utilizando systemd-boot
# Adaptado para instalaciones con archinstall
# Repositorio: https://github.com/mxhectorvega/installarch
# Ejecuci√≥n: bash <(curl -L tinyurl.com/mxinmutable)
# Fecha de actualizaci√≥n: 10/02/2025
# Versi√≥n: 1.1

set -euo pipefail

# Configuraci√≥n de colores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Variables del sistema
LOG_FILE="/var/log/btrfs-manager.log"
BOOT_LOADER_ENTRIES="/boot/loader/entries"
SNAPPER_CONFIG="/etc/snapper/configs/root"
HOOK_SCRIPT="/usr/local/bin/update-boot-entries"

# Funci√≥n de registro mejorada
log() {
    local tipo="$1"
    local mensaje="$2"
    local color

    case $tipo in
        "√âXITO") color="${GREEN}" ;;
        "ADVERTENCIA") color="${YELLOW}" ;;
        "ERROR") color="${RED}" ;;
        "INFO") color="${CYAN}" ;;
        *) color="${NC}" ;;
    esac

    echo -e "${MAGENTA}[$(date '+%Y-%m-%d %H:%M:%S')] ${color}${tipo}: ${mensaje}${NC}" | tee -a "$LOG_FILE"
}

# Manejo de errores robusto
manejar_error() {
    log "ERROR" "Fallo en l√≠nea $1: $2"
    log "ADVERTENCIA" "Realizando limpieza..."

    if mountpoint -q /mnt/root; then
        umount -l /mnt/root || true
    fi
    rm -rf /mnt/root

    log "ERROR" "Ejecuci√≥n abortada. Verifique el log: ${LOG_FILE}"
    exit 1
}

trap 'manejar_error ${LINENO} "$BASH_COMMAND"' ERR

# Verificaci√≥n de subvol√∫menes Btrfs
verificar_estructura() {
    log "INFO" "üîç Verificando estructura Btrfs..."

    local subvolumenes=("@home" "@.snapshots" "@log" "@pkgs")
    local dispositivo=$(findmnt / -o SOURCE -n | sed 's/\[.*\]//')

    mkdir -p /mnt/root || {
        log "ERROR" "No se pudo crear directorio temporal"
        exit 1
    }

    if ! mount -t btrfs -o subvol=@ "$dispositivo" /mnt/root; then
        log "ERROR" "Error al montar subvolumen ra√≠z"
        exit 1
    fi

    for subvol in "${subvolumenes[@]}"; do
        if ! btrfs subvolume list /mnt/root | grep -q "path $subvol$"; then
            log "ERROR" "Subvolumen $subvol no encontrado"
            umount /mnt/root
            exit 1
        fi
    done

    umount /mnt/root
    rm -rf /mnt/root
    log "√âXITO" "‚úÖ Estructura Btrfs validada"
}

# Instalaci√≥n de dependencias
instalar_dependencias() {
    log "INFO" "üì¶ Instalando paquetes necesarios..."

    local paquetes=(
        snapper snap-pac grub-btrfs
        btrfs-progs inotify-tools
        python-dbus python-notify2
        dosfstools efibootmgr
    )

    for pkg in "${paquetes[@]}"; do
        if ! pacman -Qi "$pkg" &>/dev/null; then
            log "INFO" "Instalando: $pkg..."
            pacman -S --noconfirm "$pkg" | tee -a "$LOG_FILE"
        else
            log "INFO" "$pkg ya est√° instalado"
        fi
    done
}

# Configuraci√≥n de Snapper
configurar_snapper() {
    log "INFO" "‚öôÔ∏è Configurando Snapper..."

    if [[ ! -f "$SNAPPER_CONFIG" ]]; then
        log "INFO" "Creando configuraci√≥n inicial..."
        snapper -c root create-config /.snapshots | tee -a "$LOG_FILE"

        log "INFO" "Ajustando pol√≠ticas..."
        snapper -c root set-config \
            ALLOW_USERS=root \
            TIMELINE_LIMIT_HOURLY="5" \
            TIMELINE_LIMIT_DAILY="7" \
            TIMELINE_LIMIT_WEEKLY="0" | tee -a "$LOG_FILE"

        chmod 750 /.snapshots
        chown :wheel /.snapshots
    fi

    systemctl enable --now snapper-timeline.timer snapper-cleanup.timer
    log "√âXITO" "‚úÖ Snapper configurado"
}

# Sistema de actualizaciones
configurar_actualizaciones() {
    log "INFO" "üîÑ Configurando actualizaciones transaccionales..."

    cat <<'EOF' > /usr/bin/transactional-update
#!/bin/bash
set -euo pipefail

LOG_FILE="/var/log/transactional-update.log"
SNAPSHOT_ID=$(snapper create -t pre --print-number --description "Actualizaci√≥n autom√°tica")

# Registrar inicio
echo -e "\n[$(date '+%Y-%m-%d %H:%M:%S')] Iniciando actualizaci√≥n (#$SNAPSHOT_ID)" >> $LOG_FILE

# Crear entorno seguro
btrfs subvolume snapshot /.snapshots/$SNAPSHOT_ID/snapshot /.snapshots/$SNAPSHOT_ID/writable
mount --bind / /.snapshots/$SNAPSHOT_ID/writable

# Funci√≥n de limpieza
limpiar() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Limpiando..." >> $LOG_FILE
    umount -l /.snapshots/$SNAPSHOT_ID/writable || true
    btrfs subvolume delete /.snapshots/$SNAPSHOT_ID/writable 2>>$LOG_FILE
    snapper delete $SNAPSHOT_ID 2>>$LOG_FILE
    exit 1
}
trap limpiar ERR

# Ejecutar actualizaci√≥n
echo "[$(date '+%Y-%m-%d %H:%M:%S')] Actualizando sistema..." >> $LOG_FILE
arch-chroot /.snapshots/$SNAPSHOT_ID/writable pacman -Syu --noconfirm 2>>$LOG_FILE

# Snapshot post-actualizaci√≥n
echo "[$(date '+%Y-%m-%d %H:%M:%S')] Creando snapshot final..." >> $LOG_FILE
snapper create -t post --pre-number $SNAPSHOT_ID --description "Post-actualizaci√≥n" 2>>$LOG_FILE

# Actualizar entradas de arranque
/usr/local/bin/update-boot-entries

echo "[$(date '+%Y-%m-%d %H:%M:%S')] Proceso completado" >> $LOG_FILE
EOF

    chmod +x /usr/bin/transactional-update

    # Configurar servicio systemd
    cat <<EOF > /etc/systemd/system/transactional-update.service
[Unit]
Description=Actualizaci√≥n Transaccional
After=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/bin/transactional-update
EOF

    cat <<EOF > /etc/systemd/system/transactional-update.timer
[Unit]
Description=Actualizaciones Autom√°ticas Diarias

[Timer]
OnCalendar=daily
Persistent=true
RandomizedDelaySec=1h

[Install]
WantedBy=timers.target
EOF

    systemctl daemon-reload
    systemctl enable --now transactional-update.timer
    log "√âXITO" "‚úÖ Sistema de actualizaciones listo"
}

# Configuraci√≥n de systemd-boot (CORREGIDO)
configurar_boot() {
    log "INFO" "üë¢ Configurando systemd-boot..."

    # Crear hook de actualizaci√≥n mejorado
    cat <<'EOF' > $HOOK_SCRIPT
#!/bin/bash
set -euo pipefail

# Variables cr√≠ticas
BOOT_ENTRIES="/boot/loader/entries"
ROOT_DEV=$(findmnt / -o SOURCE -n | sed 's/\[.*\]//')
ROOT_UUID=$(blkid -s UUID -o value "$ROOT_DEV")
KERNEL=$(basename /boot/vmlinuz-* | sort -V | tail -n1 | sed 's/vmlinuz-//')
CURRENT_KERNEL="/boot/vmlinuz-$KERNEL"
INITRAMFS="/boot/initramfs-$KERNEL.img"

# Crear directorio si no existe
mkdir -p "$BOOT_ENTRIES"

# Limpiar entradas antiguas
rm -f "$BOOT_ENTRIES"/arch-snapshot-*.conf

# Entrada principal
cat <<CONF > "$BOOT_ENTRIES/arch.conf"
title Arch Linux (Actual)
linux $CURRENT_KERNEL
initrd $INITRAMFS
options root=UUID=$ROOT_UUID rootflags=subvol=@,defaults,noatime,compress=zstd rw
CONF

# Generar entradas para snapshots
snapper -c root list | awk '/pre|post/ {print $1}' | while read -r snap_id; do
    DESCRIPCION=$(snapper -c root info "$snap_id" | grep "Description" | cut -d':' -f2 | sed 's/^ *//;s/ *$//')

    cat <<CONF > "$BOOT_ENTRIES/arch-snapshot-$snap_id.conf"
title Arch Linux (Snapshot #$snap_id) - $DESCRIPCION
linux $CURRENT_KERNEL
initrd $INITRAMFS
options root=UUID=$ROOT_UUID rootflags=subvol=@.snapshots/$snap_id/snapshot,defaults,noatime,compress=zstd rw
CONF
done

# Actualizar bootloader
bootctl update
EOF

    chmod +x $HOOK_SCRIPT

    # A√±adir hook a Snapper
    echo "POST_CREATE_SNAPSHOT=\"$HOOK_SCRIPT\"" >> /etc/snapper/configs/root

    # Forzar primera ejecuci√≥n
    $HOOK_SCRIPT
    log "√âXITO" "‚úÖ Entradas de arranque generadas"
}

# Funci√≥n principal
main() {
    log "INFO" "üöÄ Iniciando configuraci√≥n del sistema"
    verificar_estructura
    instalar_dependencias
    configurar_snapper
    configurar_actualizaciones
    configurar_boot

    log "√âXITO" "üéâ Configuraci√≥n completada exitosamente!"
    log "ADVERTENCIA" "‚ö†Ô∏è Pasos finales:"
    log "INFO" "1. Verifique las entradas: ls -l /boot/loader/entries"
    log "INFO" "2. Revise los timers: systemctl list-timers"
    log "INFO" "3. Ejecute una prueba: sudo transactional-update"
    log "INFO" "4. Monitorice logs: tail -f $LOG_FILE y journalctl"
}

main "$@"
#up2
