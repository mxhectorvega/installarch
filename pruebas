#!/bin/bash

# Colores para los mensajes
ROJO='\033[0;31m'
VERDE='\033[0;32m'
AMARILLO='\033[1;33m'
AZUL='\033[0;34m'
NC='\033[0m'

# Función para imprimir mensajes con colores
log_mensaje() {
    local tipo=$1
    local mensaje=$2
    case $tipo in
        "INFO") echo -e "${AZUL}[INFO]${NC} $mensaje" ;;
        "ERROR") echo -e "${ROJO}[ERROR]${NC} $mensaje" ;;
        "EXITO") echo -e "${VERDE}[ÉXITO]${NC} $mensaje" ;;
        "AVISO") echo -e "${AMARILLO}[AVISO]${NC} $mensaje" ;;
    esac
}

# Función para registrar errores
registrar_error() {
    local mensaje=$1
    local archivo_log="/var/log/transactional-update.log"
    echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $mensaje" >> "$archivo_log"
    log_mensaje "ERROR" "$mensaje"
}

# Verificar si se está ejecutando como root
verificar_root() {
    if [ "$EUID" -ne 0 ]; then
        log_mensaje "ERROR" "Este script debe ejecutarse como root"
        exit 1
    fi
}

# Verificar e instalar dependencias
instalar_dependencias() {
    local dependencias=("snapper" "btrfs-progs" "systemd-boot-manager" "rsync")
    log_mensaje "INFO" "Verificando dependencias..."

    for dep in "${dependencias[@]}"; do
        if ! pacman -Qi "$dep" >/dev/null 2>&1; then
            log_mensaje "INFO" "Instalando $dep..."
            if ! pacman -S --noconfirm "$dep"; then
                registrar_error "No se pudo instalar $dep"
                return 1
            fi
        fi
    done
    return 0
}

# Configurar Snapper
configurar_snapper() {
    log_mensaje "INFO" "Configurando Snapper..."

    if [ ! -d "/.snapshots" ]; then
        mkdir /.snapshots
    fi

    if ! snapper create-config /; then
        registrar_error "Error al crear la configuración de Snapper"
        return 1
    fi

    # Configurar retención de snapshots
    sed -i 's/^NUMBER_LIMIT=.*/NUMBER_LIMIT="10"/' /etc/snapper/configs/root
    sed -i 's/^NUMBER_LIMIT_IMPORTANT=.*/NUMBER_LIMIT_IMPORTANT="5"/' /etc/snapper/configs/root

    return 0
}

# Función principal de actualización transaccional
realizar_actualizacion() {
    log_mensaje "INFO" "Iniciando actualización transaccional..."

    # Crear snapshot pre-actualización
    local pre_snapshot=$(snapper create --type pre --print-number --description "Pre-actualización")

    # Actualizar el sistema
    if ! pacman -Syu --noconfirm; then
        registrar_error "Error durante la actualización del sistema"
        return 1
    fi

    # Crear snapshot post-actualización
    local post_snapshot=$(snapper create --type post --print-number --description "Post-actualización" --pre-number "$pre_snapshot")

    # Actualizar entradas de systemd-boot
    actualizar_systemd_boot "$post_snapshot"

    return 0
}

# Actualizar entradas de systemd-boot
actualizar_systemd_boot() {
    local snapshot_num=$1
    log_mensaje "INFO" "Actualizando entradas de systemd-boot..."

    # Crear entrada de boot para el snapshot
    cat > "/boot/loader/entries/arch-snapshot-${snapshot_num}.conf" << EOF
title Arch Linux (Snapshot ${snapshot_num})
linux /vmlinuz-linux
initrd /initramfs-linux.img
options root=LABEL=root subvol=@snapshots/${snapshot_num}/snapshot rw
EOF
}

# Limpiar snapshots antiguos
limpiar_snapshots() {
    log_mensaje "INFO" "Limpiando snapshots antiguos..."
    snapper cleanup number
}

# Crear servicios y timers systemd
crear_servicios_systemd() {
    # Servicio de actualización transaccional
    cat > "/etc/systemd/system/transactional-update.service" << EOF
[Unit]
Description=Actualización Transaccional de Arch Linux
After=network.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/transactional-update.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF

    # Timer para actualizaciones automáticas
    cat > "/etc/systemd/system/transactional-update.timer" << EOF
[Unit]
Description=Timer para Actualización Transaccional

[Timer]
OnCalendar=daily
Persistent=true

[Install]
WantedBy=timers.target
EOF

    # Recargar systemd y habilitar servicios
    systemctl daemon-reload
    systemctl enable --now transactional-update.timer
}

# Función principal
main() {
    verificar_root

    if ! instalar_dependencias; then
        exit 1
    fi

    if ! configurar_snapper; then
        exit 1
    fi

    crear_servicios_systemd

    if ! realizar_actualizacion; then
        exit 1
    fi

    limpiar_snapshots

    log_mensaje "EXITO" "Configuración completada exitosamente"
}

# Si se ejecuta directamente el script
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi

#up1
