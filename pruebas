#!/usr/bin/env bash

# Strict mode mejorado
set -eo pipefail
shopt -s inherit_errexit

# Debug mode mejorado
exec 3> "$HOME/arch_install.debug.log"
BASH_XTRACEFD="3"
PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
RED='\033[0;31m'
PURPLE='\033[0;35m'
NC='\033[0m'

# Variables
LOG_FILE="$HOME/arch_install.log"
ERROR_LOG="$HOME/arch_install.error.log"
DEBUG_DIR="$HOME/arch_install.debug"
INSTALLED_PACKAGES=()
TEMP_DIR=$(mktemp -d -t arch_installer_XXXXXX)

# Inicializar logs desde el principio
{
    echo "=== Inicio de ejecución: $(date) ==="
    echo "Usuario: $(whoami)"
    echo "Terminal: ${TERM:-unknown}"
    echo "Modo de ejecución: $([ -t 0 ] && echo 'Interactivo' || echo 'No interactivo')"
} | tee "$LOG_FILE" "$ERROR_LOG" >/dev/null

# Verificación inicial de requisitos mejorada
check_requirements() {
    echo -e "${YELLOW}Verificando requisitos...${NC}" | tee -a "$LOG_FILE"

    # Verificar si es Arch Linux
    if ! grep -q "Arch Linux" /etc/os-release 2>/dev/null; then
        echo -e "${RED}Error: Este script solo funciona en Arch Linux${NC}" | tee -a "$LOG_FILE" "$ERROR_LOG"
        exit 1
    fi

    # Verificar e instalar herramientas básicas
    required_tools=("curl" "sudo" "less" "grep" "mktemp")
    missing_tools=()

    for tool in "${required_tools[@]}"; do
        if ! command -v "$tool" &>/dev/null; then
            missing_tools+=("$tool")
        fi
    done

    if [ ${#missing_tools[@]} -gt 0 ]; then
        echo -e "${YELLOW}Instalando herramientas faltantes: ${missing_tools[*]}${NC}" | tee -a "$LOG_FILE"
        sudo pacman -Sy --noconfirm --needed "${missing_tools[@]}" || {
            echo -e "${RED}Error al instalar dependencias${NC}" | tee -a "$LOG_FILE" "$ERROR_LOG"
            exit 1
        }
    fi

    # Verificar permisos de sudo
    if ! sudo -n true 2>/dev/null; then
        echo -e "${YELLOW}Se requiere privilegios de sudo${NC}" | tee -a "$LOG_FILE"
        sudo -v || {
            echo -e "${RED}Error: Fallo al verificar sudo${NC}" | tee -a "$LOG_FILE" "$ERROR_LOG"
            exit 1
        }
    fi

    # Crear directorios necesarios
    mkdir -p "$TEMP_DIR" "$DEBUG_DIR"

    echo -e "${GREEN}✓ Todos los requisitos cumplidos${NC}" | tee -a "$LOG_FILE"
}

# Función de limpieza mejorada
cleanup() {
    local status=$?
    trap - EXIT INT TERM

    {
        echo -e "\n=== Limpieza iniciada: $(date) ==="
        echo -e "Estado de salida: $status"

        if [ $status -ne 0 ]; then
            echo -e "${RED}Error detectado. Código: $status${NC}"
            echo -e "Últimos comandos ejecutados:"
            tail -n 15 "$LOG_FILE"

            echo -e "\nContenido temporal guardado en: $DEBUG_DIR"
            cp -vr "$TEMP_DIR"/* "$DEBUG_DIR/" 2>/dev/null || true

            if [ ${#INSTALLED_PACKAGES[@]} -gt 0 ]; then
                echo -e "\nDesinstalando paquetes: ${INSTALLED_PACKAGES[*]}"
                sudo pacman -R --noconfirm "${INSTALLED_PACKAGES[@]}" 2>/dev/null || true
            fi
        else
            echo -e "${GREEN}Limpieza exitosa${NC}"
            rm -rf "$TEMP_DIR"
        fi
    } | tee -a "$LOG_FILE" "$ERROR_LOG" >/dev/null

    exit $status
}

trap cleanup EXIT INT TERM

# Resto del script sin cambios en las funciones de menú pero con mejoras de logging
# ... (funciones show_welcome, show_menu, register_package, etc. iguales pero con tee -a "$LOG_FILE")

# Función para ejecutar script mejorada
execute_script() {
    local url="$1"
    local temp_script="$TEMP_DIR/script_$(date +%s).sh"

    {
        echo -e "\n${YELLOW}Verificando URL: $url${NC}"
        if ! curl -Ifs --retry 3 "$url" >/dev/null; then
            echo -e "${RED}Error: URL no accesible${NC}"
            return 1
        fi

        echo -e "${YELLOW}Descargando script...${NC}"
        curl -fsSL --retry 3 "$url" > "$temp_script" || {
            echo -e "${RED}Error al descargar el script${NC}"
            return 1
        }

        [ -s "$temp_script" ] || {
            echo -e "${RED}Error: Script vacío${NC}"
            return 1
        }

        chmod +x "$temp_script"
        echo -e "${GREEN}Script descargado: $(stat -c %s "$temp_script") bytes${NC}"

        echo -e "${YELLOW}Validando sintaxis...${NC}"
        bash -n "$temp_script" || {
            echo -e "${RED}Error de sintaxis detectado${NC}"
            return 1
        }

        echo -e "\n${YELLOW}Ejecutando script...${NC}\n"
        bash "$temp_script" 2>&1 | tee -a "$ERROR_LOG"
        return ${PIPESTATUS[0]}
    } | tee -a "$LOG_FILE"
}

# ... (resto de funciones y main sin cambios)

# Función principal actualizada
main() {
    check_requirements

    # Forzar modo interactivo si se ejecuta desde pipe
    [ -t 0 ] || {
        echo -e "${YELLOW}Advertencia: Ejecución no interactiva detectada${NC}" | tee -a "$LOG_FILE"
        echo -e "Si hay prompts de contraseña, deberás ejecutar el script localmente" | tee -a "$LOG_FILE"
    }

    while true; do
        show_welcome
        show_menu
        # ... (resto igual)
    done
}

main "$@"
#loco
