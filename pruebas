#!/usr/bin/env bash
set -euo pipefail

# Configuración de colores para mensajes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # Sin color

# Variables de configuración
LOG_FILE="/var/log/transactional-setup.log"
BOOT_LOADER_ENTRIES="/boot/loader/entries"
SNAPPER_CONFIG="/etc/snapper/configs/root"
SYSTEMD_SERVICE="/etc/systemd/system/transactional-update.service"
SYSTEMD_TIMER="/etc/systemd/system/transactional-update.timer"
HOOK_SCRIPT="/usr/local/bin/update-systemd-boot-entries"

# Función de registro mejorada
log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local color

    case $level in
        "INFO") color="${BLUE}" ;;
        "SUCCESS") color="${GREEN}" ;;
        "WARNING") color="${YELLOW}" ;;
        "ERROR") color="${RED}" ;;
        *) color="${NC}" ;;
    esac

    echo -e "${MAGENTA}[${timestamp}] ${color}${level}: ${message}${NC}" | tee -a "$LOG_FILE"
}

# Manejo de errores robusto
error_handler() {
    log "ERROR" "Fallo en línea $1: $2"
    log "WARNING" "Iniciando proceso de recuperación..."

    # Rollback de montajes
    if mountpoint -q /mnt/root; then
        umount -l /mnt/root || true
        rm -rf /mnt/root
    fi

    # Eliminar última configuración generada
    local last_snap=$(snapper -c root list 2>/dev/null | tail -n2 | head -n1 | awk '{print $1}')
    if [[ $last_snap =~ ^[0-9]+$ ]]; then
        log "WARNING" "Eliminando snapshot fallido #${last_snap}"
        snapper delete $last_snap 2>/dev/null || true
    fi

    log "ERROR" "Proceso abortado. Verifique el log: ${LOG_FILE}"
    exit 1
}

trap 'error_handler ${LINENO} "$BASH_COMMAND"' ERR

# Verificar ejecución como root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        log "ERROR" "Este script debe ejecutarse como root"
        exit 1
    fi
}

# Instalación inteligente de dependencias
install_dependencies() {
    log "INFO" "Verificando dependencias del sistema..."
    local dependencies=(
        snapper grub-btrfs snap-pac python-dbus
        python-notify2 inotify-tools btrfs-progs
        systemd-boot-manager mkinitcpio
    )

    for pkg in "${dependencies[@]}"; do
        if ! pacman -Qi "$pkg" &>/dev/null; then
            log "INFO" "Instalando ${pkg}..."
            paru -S --noconfirm "$pkg" | tee -a "$LOG_FILE"
        else
            log "INFO" "${pkg} ya está instalado"
        fi
    done
}

# Configuración robusta de Snapper
configure_snapper() {
    log "INFO" "Configurando Snapper..."
    local root_dev=$(findmnt / -o SOURCE -n | sed 's/\[.*\]//;s/^ //')
    local subvol_path="@.snapshots"

    # Manejo de subvolumen existente
    if btrfs subvolume list / | grep -q "path ${subvol_path}$"; then
        log "WARNING" "Subvolumen .snapshots existente detectado"

        mkdir -p /mnt/root
        log "INFO" "Montando dispositivo raíz ${root_dev}"
        mount -t btrfs -o noatime,compress=zstd "${root_dev}" /mnt/root

        if [ -d "/mnt/root/${subvol_path}" ]; then
            log "WARNING" "Eliminando subvolumen conflictivo..."
            btrfs subvolume delete "/mnt/root/${subvol_path}" | tee -a "$LOG_FILE"
            sync
        fi

        log "INFO" "Creando nuevo subvolumen..."
        btrfs subvolume create "/mnt/root/${subvol_path}" | tee -a "$LOG_FILE"

        umount /mnt/root
        rm -rf /mnt/root
    fi

    # Eliminar configuración existente
    if snapper list-configs | grep -q "root"; then
        log "WARNING" "Eliminando configuración previa de Snapper..."
        snapper -c root delete-config | tee -a "$LOG_FILE"
    fi

    # Nueva configuración
    log "INFO" "Creando configuración de Snapper..."
    snapper -c root create-config -f btrfs / | tee -a "$LOG_FILE"

    # Optimizar configuración
    snapper -c root set-config \
        ALLOW_USERS=root \
        TIMELINE_LIMIT_HOURLY="5" \
        TIMELINE_LIMIT_DAILY="7" \
        TIMELINE_LIMIT_WEEKLY="0" | tee -a "$LOG_FILE"

    # Permisos y servicios
    chmod 750 /.snapshots
    chown :wheel /.snapshots
    systemctl enable --now snapper-timeline.timer snapper-cleanup.timer
}

# Sistema de actualizaciones transaccionales
setup_transactional_updates() {
    log "INFO" "Configurando actualizaciones transaccionales..."

    cat <<'EOF' > /usr/bin/transactional-update
#!/bin/bash
set -euo pipefail

SNAPSHOT_ID=$(snapper create -t pre --print-number --description "Actualización automática")
LOG_FILE="/var/log/transactional-update.log"

# Crear entorno de actualización
btrfs subvolume snapshot /.snapshots/${SNAPSHOT_ID}/snapshot /.snapshots/${SNAPSHOT_ID}/writable
mount --bind / /.snapshots/${SNAPSHOT_ID}/writable

cleanup() {
    umount -l /.snapshots/${SNAPSHOT_ID}/writable
    btrfs subvolume delete /.snapshots/${SNAPSHOT_ID}/writable
    snapper delete ${SNAPSHOT_ID}
    exit 1
}
trap cleanup ERR

# Ejecutar actualización
arch-chroot /.snapshots/${SNAPSHOT_ID}/writable pacman -Syu --noconfirm

# Crear snapshot post-actualización
snapper create -t post --pre-number ${SNAPSHOT_ID} --description "Post-actualización"

# Actualizar entradas de arranque
/usr/local/bin/update-systemd-boot-entries
EOF

    chmod +x /usr/bin/transactional-update

    # Configurar servicio systemd
    cat <<EOF > ${SYSTEMD_SERVICE}
[Unit]
Description=Actualización Transaccional
After=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/bin/transactional-update
EOF

    cat <<EOF > ${SYSTEMD_TIMER}
[Unit]
Description=Actualizaciones Diarias Automáticas

[Timer]
OnCalendar=daily
Persistent=true
RandomizedDelaySec=1h

[Install]
WantedBy=timers.target
EOF

    systemctl daemon-reload
    systemctl enable --now transactional-update.timer
}

# Configuración de Systemd-Boot
setup_systemdboot() {
    log "INFO" "Configurando Systemd-Boot..."

    # Crear hook de actualización
    cat <<'EOF' > ${HOOK_SCRIPT}
#!/bin/bash
set -euo pipefail

root_partuuid=$(blkid -s PARTUUID -o value $(findmnt / -o SOURCE -n))
current_kernel=$(ls /usr/lib/modules | grep -v extramodules | sort -V | tail -n1)

# Eliminar entradas antiguas
find "${BOOT_LOADER_ENTRIES}" -name "arch-snapshot-*.conf" -delete

# Generar nuevas entradas
snapper -c root list | awk '/pre|post/ {print $1}' | while read snapshot_id; do
    snapshot_desc=$(snapper -c root info $snapshot_id | grep "Description" | cut -d':' -f2 | sed 's/^[ \t]*//;s/[ \t]*$//')
    cat <<CONF > "${BOOT_LOADER_ENTRIES}/arch-snapshot-${snapshot_id}.conf"
title Arch Linux (Snapshot #${snapshot_id}) - ${snapshot_desc}
linux /vmlinuz-${current_kernel}
initrd /initramfs-${current_kernel}.img
options root=PARTUUID=${root_partuuid} rootflags=subvol=@.snapshots/${snapshot_id}/snapshot rw
CONF
done

# Actualizar firmware UEFI
bootctl update
EOF

    chmod +x ${HOOK_SCRIPT}

    # Configurar hook en Snapper
    echo "POST_CREATE_SNAPSHOT=\"${HOOK_SCRIPT}\"" >> /etc/snapper/configs/root

    # Generar entradas iniciales
    ${HOOK_SCRIPT}

    # Entrada principal
    local root_partuuid=$(blkid -s PARTUUID -o value $(findmnt / -o SOURCE -n))
    local current_kernel=$(ls /usr/lib/modules | grep -v extramodules | sort -V | tail -n1)

    cat <<EOF > "${BOOT_LOADER_ENTRIES}/arch.conf"
title Arch Linux (Current)
linux /vmlinuz-${current_kernel}
initrd /initramfs-${current_kernel}.img
options root=PARTUUID=${root_partuuid} rootflags=subvol=@ rw
EOF

    log "SUCCESS" "Entradas de Systemd-Boot actualizadas"
}

# Limpieza automática de snapshots
setup_cleanup() {
    log "INFO" "Configurando limpieza automática..."

    cat <<EOF > /etc/systemd/system/snapper-cleanup.service
[Unit]
Description=Limpieza de Snapshots Antiguos

[Service]
Type=oneshot
ExecStart=/usr/bin/sh -c 'snapper cleanup number && snapper cleanup timeline'
EOF

    cat <<EOF > /etc/systemd/system/snapper-cleanup.timer
[Unit]
Description=Limpieza Semanal de Snapshots

[Timer]
OnCalendar=weekly
Persistent=true

[Install]
WantedBy=timers.target
EOF

    systemctl daemon-reload
    systemctl enable --now snapper-cleanup.timer
}

# Función principal
main() {
    check_root
    install_dependencies
    configure_snapper
    setup_transactional_updates
    setup_systemdboot
    setup_cleanup

    log "SUCCESS" "Configuración completada exitosamente!"
    log "INFO" "Recomendaciones finales:"
    log "INFO" "1. Verifique las entradas de arranque: ${BOOT_LOADER_ENTRIES}"
    log "INFO" "2. Revise los timers: systemctl list-timers"
    log "INFO" "3. Monitorice los logs: tail -f ${LOG_FILE}"
    log "WARNING" "Se recomienda reiniciar el sistema para aplicar todos los cambios"
}

main "$@"
#test16
