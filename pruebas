#!/usr/bin/env bash
set -euo pipefail

# Configuración de colores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Variables del sistema
LOG_FILE="/var/log/btrfs-setup.log"
BOOT_LOADER_ENTRIES="/boot/loader/entries"
SNAPPER_CONFIG="/etc/snapper/configs/root"
HOOK_SCRIPT="/usr/local/bin/update-boot-entries"

# Función de registro mejorada
log() {
    local tipo="$1"
    local mensaje="$2"
    local color

    case $tipo in
        "ÉXITO") color="${GREEN}" ;;
        "ADVERTENCIA") color="${YELLOW}" ;;
        "ERROR") color="${RED}" ;;
        "INFO") color="${CYAN}" ;;
        *) color="${NC}" ;;
    esac

    echo -e "${MAGENTA}[$(date '+%Y-%m-%d %H:%M:%S')] ${color}${tipo}: ${mensaje}${NC}" | tee -a "$LOG_FILE"
}

# Manejo de errores
manejar_error() {
    log "ERROR" "Fallo en línea $1: $2"
    log "ADVERTENCIA" "Intentando recuperación..."

    if mountpoint -q /mnt/root; then
        umount -l /mnt/root || true
        rm -rf /mnt/root
    fi

    log "ERROR" "Proceso abortado. Verifique el log: ${LOG_FILE}"
    exit 1
}

trap 'manejar_error ${LINENO} "$BASH_COMMAND"' ERR

# Verificar subvolúmenes requeridos
verificar_subvolumenes() {
    log "INFO" "Verificando estructura de subvolúmenes..."

    local subvolumenes=("@home" "@.snapshots" "@log" "@pkgs")
    local dispositivo_raiz=$(findmnt / -o SOURCE -n | sed 's/\[.*\]//')

    mount -t btrfs -o subvol=@ "${dispositivo_raiz}" /mnt/root

    for subvol in "${subvolumenes[@]}"; do
        if ! btrfs subvolume list /mnt/root | grep -q "path ${subvol}$"; then
            log "ERROR" "Subvolumen ${subvol} no encontrado!"
            exit 1
        fi
    done

    umount /mnt/root
    rm -rf /mnt/root
    log "ÉXITO" "Estructura de subvolúmenes validada"
}

# Instalación de dependencias
instalar_dependencias() {
    log "INFO" "Instalando paquetes necesarios..."

    local dependencias=(
        snapper snap-pac grub-btrfs btrfs-progs
        inotify-tools python-dbus python-notify2
    )

    for pkg in "${dependencias[@]}"; do
        if ! pacman -Qi "$pkg" &>/dev/null; then
            log "INFO" "Instalando: ${pkg}..."
            pacman -S --noconfirm "$pkg" | tee -a "$LOG_FILE"
        else
            log "INFO" "Paquete ${pkg} ya instalado"
        fi
    done
}

# Configuración de Snapper
configurar_snapper() {
    log "INFO" "Configurando Snapper..."

    if [[ ! -f "$SNAPPER_CONFIG" ]]; then
        log "INFO" "Creando configuración para subvolumen raíz..."
        snapper -c root create-config /.snapshots | tee -a "$LOG_FILE"

        log "INFO" "Ajustando configuración..."
        snapper -c root set-config \
            ALLOW_USERS=root \
            TIMELINE_LIMIT_HOURLY="5" \
            TIMELINE_LIMIT_DAILY="7" \
            TIMELINE_LIMIT_WEEKLY="0" | tee -a "$LOG_FILE"

        chmod 750 /.snapshots
        chown :wheel /.snapshots
    fi

    systemctl enable --now snapper-timeline.timer snapper-cleanup.timer
    log "ÉXITO" "Snapper configurado correctamente"
}

# Configurar actualizaciones transaccionales
configurar_actualizaciones() {
    log "INFO" "Configurando sistema de actualizaciones..."

    cat <<'EOF' > /usr/bin/transactional-update
#!/bin/bash
set -euo pipefail

# Variables del sistema
LOG_FILE="/var/log/transactional-update.log"
SNAPSHOT_ID=$(snapper create -t pre --print-number --description "Actualización automática")

# Registrar inicio
echo -e "\n[$(date '+%Y-%m-%d %H:%M:%S')] Iniciando actualización (#${SNAPSHOT_ID})" >> $LOG_FILE

# Crear entorno de actualización
btrfs subvolume snapshot /.snapshots/${SNAPSHOT_ID}/snapshot /.snapshots/${SNAPSHOT_ID}/writable
mount --bind / /.snapshots/${SNAPSHOT_ID}/writable

# Función de limpieza
limpiar() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Realizando limpieza..." >> $LOG_FILE
    umount -l /.snapshots/${SNAPSHOT_ID}/writable || true
    btrfs subvolume delete /.snapshots/${SNAPSHOT_ID}/writable 2>>$LOG_FILE
    snapper delete ${SNAPSHOT_ID} 2>>$LOG_FILE
    exit 1
}
trap limpiar ERR

# Ejecutar actualización
echo "[$(date '+%Y-%m-%d %H:%M:%S')] Actualizando sistema..." >> $LOG_FILE
arch-chroot /.snapshots/${SNAPSHOT_ID}/writable pacman -Syu --noconfirm 2>>$LOG_FILE

# Crear snapshot post-actualización
echo "[$(date '+%Y-%m-%d %H:%M:%S')] Creando snapshot final..." >> $LOG_FILE
snapper create -t post --pre-number ${SNAPSHOT_ID} --description "Post-actualización" 2>>$LOG_FILE

# Actualizar entradas de arranque
/usr/local/bin/update-boot-entries

echo "[$(date '+%Y-%m-%d %H:%M:%S')] Actualización completada" >> $LOG_FILE
EOF

    chmod +x /usr/bin/transactional-update

    # Configurar servicio systemd
    cat <<EOF > /etc/systemd/system/transactional-update.service
[Unit]
Description=Actualización Transaccional del Sistema
After=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/bin/transactional-update
EOF

    cat <<EOF > /etc/systemd/system/transactional-update.timer
[Unit]
Description=Actualizaciones Automáticas Diarias

[Timer]
OnCalendar=daily
Persistent=true
RandomizedDelaySec=1h

[Install]
WantedBy=timers.target
EOF

    systemctl daemon-reload
    systemctl enable --now transactional-update.timer
    log "ÉXITO" "Sistema de actualizaciones configurado"
}

# Configurar entradas de arranque
configurar_boot() {
    log "INFO" "Configurando systemd-boot..."

    # Crear script de actualización de entradas
    cat <<'EOF' > $HOOK_SCRIPT
#!/bin/bash
set -euo pipefail

# Variables del sistema
ROOT_UUID=$(blkid -s PARTUUID -o value $(findmnt / -o SOURCE -n))
KERNEL_ACTUAL=$(ls /usr/lib/modules | grep -v extramodules | sort -V | tail -n1)

# Crear entrada principal
cat <<CONF > "${BOOT_LOADER_ENTRIES}/arch.conf"
title Arch Linux (Actual)
linux /vmlinuz-${KERNEL_ACTUAL}
initrd /initramfs-${KERNEL_ACTUAL}.img
options root=PARTUUID=${ROOT_UUID} rootflags=subvol=@,defaults,noatime,compress=zstd rw
CONF

# Crear entradas para snapshots
for snapshot in $(snapper -c root list | awk '/pre|post/ {print $1}'); do
    DESCRIPCION=$(snapper -c root info $snapshot | grep "Description" | cut -d':' -f2 | sed 's/^ *//')

    cat <<CONF > "${BOOT_LOADER_ENTRIES}/arch-snapshot-${snapshot}.conf"
title Arch Linux (Snapshot ${snapshot}) - ${DESCRIPCION}
linux /vmlinuz-${KERNEL_ACTUAL}
initrd /initramfs-${KERNEL_ACTUAL}.img
options root=PARTUUID=${ROOT_UUID} rootflags=subvol=@.snapshots/${snapshot}/snapshot,defaults,noatime,compress=zstd rw
CONF
done

# Actualizar bootloader
bootctl update
EOF

    chmod +x $HOOK_SCRIPT

    # Añadir hook a Snapper
    echo "POST_CREATE_SNAPSHOT=\"${HOOK_SCRIPT}\"" >> /etc/snapper/configs/root

    # Ejecutar primera generación
    $HOOK_SCRIPT
    log "ÉXITO" "Entradas de arranque configuradas"
}

# Función principal
main() {
    log "INFO" "Iniciando configuración del sistema Btrfs"
    verificar_subvolumenes
    instalar_dependencias
    configurar_snapper
    configurar_actualizaciones
    configurar_boot

    log "ÉXITO" "Configuración completada con éxito!"
    log "ADVERTENCIA" "Recomendaciones finales:"
    log "INFO" "1. Verifique las entradas de arranque: ${BOOT_LOADER_ENTRIES}"
    log "INFO" "2. Revise los timers: systemctl list-timers"
    log "INFO" "3. Pruebe una actualización: sudo transactional-update"
    log "INFO" "4. Monitorice los logs: tail -f ${LOG_FILE}"
}

main "$@"
#update21
